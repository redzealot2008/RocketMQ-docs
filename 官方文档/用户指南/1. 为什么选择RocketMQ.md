## 动机

在早期阶段，我们构建了基于ActiveMQ 5.x（5.3之前）的分布式消息传递中间件。我们的跨国业务把它用于异步通信，搜索，社交网络活动流，数据管道，甚至在其交易过程中。随着我们的贸易业务吞吐量的上升，来自我们的消息集群的压力也变得迫切。

## 为什么选择RocketMQ？

基于我们的研究，随着使用中增加的队列和虚拟主题，ActiveMQ IO模块达到瓶颈。我们尽力通过节流，断路器或退化来解决这个问题，但是它不能很好地工作。所以我们开始关注当时流行的消息解决方案Kafka 。不幸的是，Kafka 不能满足我们的要求，特别是在低延迟和高可靠性方面，详见[这里][1]。

在这种情况下，我们决定发明一种新的消息传递引擎来处理更广泛的用例，从传统的pub / sub方案到高容量实时零丢失容错事务系统。我们相信这个解决方案可能是有益的，所以我们想把它开源给社区。今天，超过100家公司正在使用RocketMQ的开源版本。我们还发布了基于RocketMQ的商业发行版，一款称为[阿里巴巴云平台][2]的PaaS产品。

下表演示了RocketMQ，ActiveMQ和Kafka（Apache的最流行的消息解决方案，根据[awesome-java][3]）的比较：

**RocketMQ vs. ActiveMQ vs. Kafka**

|消息产品|	客户端SDK|	协议和规范|	有序消息|	计划讯息|	批量消息|	广播消息|	消息过滤器|	服务器触发重新传输|	消息存储|	消息追溯|	消息优先级|	高可用性和故障转移|	消息追踪|	配置|	管理和操作工具|
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
|ActiveMQ|Java，.NET，C ++等|	推模式，支持OpenWire，STOMP，AMQP，MQTT，JMS|	独立消费者或独立队列可以确保排序|	支持|	不支持|	支持|	支持|	不支持|	支持使用JDBC和高性能日志（如levelDB，kahaDB）来非常快速的持久化	|支持|	支持|	支持，依赖于存储，如果使用kahadb它需要一个ZooKeeper服务器|	不支持|	默认配置为低等级，用户需要优化配置参数|	支持|
|Kafka|	Java，Scala等|	拉模式，支持TCP|	确保分区内的消息排序|	不支持|	支持，异步生产者|	不支持|	支持，您可以使用Kafka Streams过滤消息|	不支持|	高性能文件存储|	支持偏移量表示|	不支持|	支持，需要一个ZooKeeper服务器|	不支持|	Kafka使用键值对格式进行配置。这些值可以从文件或以编程方式提供。|	支持，使用终端命令公开核心指标|
|RocketMQ|	Java，C ++，Go|	拉模型，支持TCP，JMS，OpenMessaging|	确保严格排序邮件，并可以优雅地扩展|	支持|	支持，同步模式以避免信息丢失|	支持|支持，基于SQL92的属性过滤器表达式|	支持|	高性能和低延迟文件存储|	支持的时间戳和偏移量两个表示|	不支持|	支持，主从模式，不用其它工具包|	支持|	开箱即用，用户只需要注意几个配置|	支持，丰富的Web和终端命令来公开核心指标|

[1]: https://rocketmq.apache.org/rocketmq/how-to-support-more-queues-in-rocketmq/
[2]: https://intl.aliyun.com/
[3]: https://github.com/akullpp/awesome-java

https://rocketmq.apache.org/docs/motivation/